{
  "package": "pandas",
  "version": "2.3.3",
  "qualified_name": "pandas.core.tools.numeric.to_numeric",
  "file": "/var/folders/8y/1_rm_t850ndf6rxl9ggy1qdh0000gn/T/spec_pandas_h7isq7x8/pandas-2.3.3/pandas/core/tools/numeric.py",
  "signature": "(arg, errors: DateTimeErrorChoices = 'raise', downcast: Literal['integer', 'signed', 'unsigned', 'float'] | None = None, dtype_backend: DtypeBackend | lib.NoDefault = lib.no_default)",
  "parameters": [
    {
      "name": "arg",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "scalar, list, tuple, 1-d array, or Series",
      "default": null,
      "required": true,
      "nullable": false,
      "enum": null,
      "description": "Argument to be converted."
    },
    {
      "name": "errors",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "DateTimeErrorChoices",
      "default": "'raise'",
      "required": false,
      "nullable": false,
      "enum": [
        "ignore",
        "raise",
        "coerce"
      ],
      "description": "- If 'raise', then invalid parsing will raise an exception. - If 'coerce', then invalid parsing will be set as NaN. - If 'ignore', then invalid parsing will return the input."
    },
    {
      "name": "downcast",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "Literal['integer', 'signed', 'unsigned', 'float'] | None",
      "default": "None",
      "required": false,
      "nullable": false,
      "enum": null,
      "description": "Can be 'integer', 'signed', 'unsigned', or 'float'. If not None, and if the data has been successfully cast to a numerical dtype (or if the data was numeric to begin with), downcast that resulting data to the smallest numerical dtype possible according to the following rules:"
    },
    {
      "name": "dtype_backend",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "DtypeBackend | lib.NoDefault",
      "default": "lib.no_default",
      "required": false,
      "nullable": false,
      "enum": [
        "numpy_nullable",
        "pyarrow"
      ],
      "description": "Back-end data type applied to the resultant :class:`DataFrame` (still experimental). Behaviour is as follows:"
    }
  ],
  "returns": {
    "type": null,
    "description": "ret\n    Numeric if parsing succeeded.\n    Return type depends on input.  Series if Series, otherwise ndarray.\n\nSee Also\n--------\nDataFrame.astype : Cast argument to a specified dtype.\nto_datetime : Convert argument to datetime.\nto_timedelta : Convert argument to timedelta.\nnumpy.ndarray.astype : Cast a numpy array to a specified type.\nDataFrame.convert_dtypes : Convert dtypes."
  },
  "raises": null,
  "notes": null,
  "examples_code": [
    "s = pd.Series(['1.0', '2', -3])\npd.to_numeric(s)",
    "pd.to_numeric(s, downcast='float')",
    "pd.to_numeric(s, downcast='signed')",
    "s = pd.Series(['apple', '1.0', '2', -3])\npd.to_numeric(s, errors='coerce')",
    "s = pd.Series([1, 2, 3], dtype=\"Int64\")\npd.to_numeric(s, downcast=\"integer\")",
    "s = pd.Series([1.0, 2.1, 3.0], dtype=\"Float64\")\npd.to_numeric(s, downcast=\"float\")"
  ],
  "module_imports": [
    "from __future__ import annotations",
    "from typing import (",
    "import warnings",
    "import numpy as np",
    "from pandas._libs import (",
    "from pandas.util._exceptions import find_stack_level",
    "from pandas.util._validators import check_dtype_backend",
    "from pandas.core.dtypes.cast import maybe_downcast_numeric",
    "from pandas.core.dtypes.common import (",
    "from pandas.core.dtypes.dtypes import ArrowDtype",
    "from pandas.core.dtypes.generic import (",
    "from pandas.core.arrays import BaseMaskedArray",
    "from pandas.core.arrays.string_ import StringDtype",
    "    from pandas._typing import (",
    "        from pandas.core.arrays import (",
    "        from pandas import Index"
  ],
  "body_stripped": "def to_numeric(\n    arg,\n    errors: DateTimeErrorChoices = \"raise\",\n    downcast: Literal[\"integer\", \"signed\", \"unsigned\", \"float\"] | None = None,\n    dtype_backend: DtypeBackend | lib.NoDefault = lib.no_default,\n):\n    \"\"\"\n    Convert argument to a numeric type.\n\n    The default return dtype is `float64` or `int64`\n    depending on the data supplied. Use the `downcast` parameter\n    to obtain other dtypes.\n\n    Please note that precision loss may occur if really large numbers\n    are passed in. Due to the internal limitations of `ndarray`, if\n    numbers smaller than `-9223372036854775808` (np.iinfo(np.int64).min)\n    or larger than `18446744073709551615` (np.iinfo(np.uint64).max) are\n    passed in, it is very likely they will be converted to float so that\n    they can be stored in an `ndarray`. These warnings apply similarly to\n    `Series` since it internally leverages `ndarray`.\n\n    Parameters\n    ----------\n    arg : scalar, list, tuple, 1-d array, or Series\n        Argument to be converted.\n    errors : {'ignore', 'raise', 'coerce'}, default 'raise'\n        - If 'raise', then invalid parsing will raise an exception.\n        - If 'coerce', then invalid parsing will be set as NaN.\n        - If 'ignore', then invalid parsing will return the input.\n\n        .. versionchanged:: 2.2\n\n        \"ignore\" is deprecated. Catch exceptions explicitly instead.\n\n    downcast : str, default None\n        Can be 'integer', 'signed', 'unsigned', or 'float'.\n        If not None, and if the data has been successfully cast to a\n        numerical dtype (or if the data was numeric to begin with),\n        downcast that resulting data to the smallest numerical dtype\n        possible according to the following rules:\n\n        - 'integer' or 'signed': smallest signed int dtype (min.: np.int8)\n        - 'unsigned': smallest unsigned int dtype (min.: np.uint8)\n        - 'float': smallest float dtype (min.: np.float32)\n\n        As this behaviour is separate from the core conversion to\n        numeric values, any errors raised during the downcasting\n        will be surfaced regardless of the value of the 'errors' input.\n\n        In addition, downcasting will only occur if the size\n        of the resulting data's dtype is strictly larger than\n        the dtype it is to be cast to, so if none of the dtypes\n        checked satisfy that specification, no downcasting will be\n        performed on the data.\n    dtype_backend : {'numpy_nullable', 'pyarrow'}, default 'numpy_nullable'\n        Back-end data type applied to the resultant :class:`DataFrame`\n        (still experimental). Behaviour is as follows:\n\n        * ``\"numpy_nullable\"``: returns nullable-dtype-backed :class:`DataFrame`\n          (default).\n        * ``\"pyarrow\"``: returns pyarrow-backed nullable :class:`ArrowDtype`\n          DataFrame.\n\n        .. versionadded:: 2.0\n\n    Returns\n    -------\n    ret\n        Numeric if parsing succeeded.\n        Return type depends on input.  Series if Series, otherwise ndarray.\n\n    See Also\n    --------\n    DataFrame.astype : Cast argument to a specified dtype.\n    to_datetime : Convert argument to datetime.\n    to_timedelta : Convert argument to timedelta.\n    numpy.ndarray.astype : Cast a numpy array to a specified type.\n    DataFrame.convert_dtypes : Convert dtypes.\n\n    Examples\n    --------\n    Take separate series and convert to numeric, coercing when told to\n\n    >>> s = pd.Series(['1.0', '2', -3])\n    >>> pd.to_numeric(s)\n    0    1.0\n    1    2.0\n    2   -3.0\n    dtype: float64\n    >>> pd.to_numeric(s, downcast='float')\n    0    1.0\n    1    2.0\n    2   -3.0\n    dtype: float32\n    >>> pd.to_numeric(s, downcast='signed')\n    0    1\n    1    2\n    2   -3\n    dtype: int8\n    >>> s = pd.Series(['apple', '1.0', '2', -3])\n    >>> pd.to_numeric(s, errors='coerce')\n    0    NaN\n    1    1.0\n    2    2.0\n    3   -3.0\n    dtype: float64\n\n    Downcasting of nullable integer and floating dtypes is supported:\n\n    >>> s = pd.Series([1, 2, 3], dtype=\"Int64\")\n    >>> pd.to_numeric(s, downcast=\"integer\")\n    0    1\n    1    2\n    2    3\n    dtype: Int8\n    >>> s = pd.Series([1.0, 2.1, 3.0], dtype=\"Float64\")\n    >>> pd.to_numeric(s, downcast=\"float\")\n    0    1.0\n    1    2.1\n    2    3.0\n    dtype: Float32\n    \"\"\"\n    if downcast not in (None, \"integer\", \"signed\", \"unsigned\", \"float\"):\n        raise ValueError(\"invalid downcasting method provided\")\n\n    if errors not in (\"ignore\", \"raise\", \"coerce\"):\n        raise ValueError(\"invalid error value specified\")\n    if errors == \"ignore\":\n        # GH#54467\n        warnings.warn(\n            \"errors='ignore' is deprecated and will raise in a future version. \"\n            \"Use to_numeric without passing `errors` and catch exceptions \"\n            \"explicitly instead\",\n            FutureWarning,\n            stacklevel=find_stack_level(),\n        )\n\n    check_dtype_backend(dtype_backend)\n\n    is_series = False\n    is_index = False\n    is_scalars = False\n\n    if isinstance(arg, ABCSeries):\n        is_series = True\n        values = arg.values\n    elif isinstance(arg, ABCIndex):\n        is_index = True\n        if needs_i8_conversion(arg.dtype):\n            values = arg.view(\"i8\")\n        else:\n            values = arg.values\n    elif isinstance(arg, (list, tuple)):\n        values = np.array(arg, dtype=\"O\")\n    elif is_scalar(arg):\n        if is_decimal(arg):\n            return float(arg)\n        if is_number(arg):\n            return arg\n        is_scalars = True\n        values = np.array([arg], dtype=\"O\")\n    elif getattr(arg, \"ndim\", 1) > 1:\n        raise TypeError(\"arg must be a list, tuple, 1-d array, or Series\")\n    else:\n        values = arg\n\n    orig_values = values\n\n    # GH33013: for IntegerArray & FloatingArray extract non-null values for casting\n    # save mask to reconstruct the full array after casting\n    mask: npt.NDArray[np.bool_] | None = None\n    if isinstance(values, BaseMaskedArray):\n        mask = values._mask\n        values = values._data[~mask]\n\n    values_dtype = getattr(values, \"dtype\", None)\n    if isinstance(values_dtype, ArrowDtype):\n        mask = values.isna()\n        values = values.dropna().to_numpy()\n    new_mask: np.ndarray | None = None\n    if is_numeric_dtype(values_dtype):\n        pass\n    elif lib.is_np_dtype(values_dtype, \"mM\"):\n        values = values.view(np.int64)\n    else:\n        values = ensure_object(values)\n        coerce_numeric = errors not in (\"ignore\", \"raise\")\n        try:\n            values, new_mask = lib.maybe_convert_numeric(  # type: ignore[call-overload]\n                values,\n                set(),\n                coerce_numeric=coerce_numeric,\n                convert_to_masked_nullable=dtype_backend is not lib.no_default\n                or isinstance(values_dtype, StringDtype)\n                and values_dtype.na_value is libmissing.NA,\n            )\n        except (ValueError, TypeError):\n            if errors == \"raise\":\n                raise\n            values = orig_values\n\n    if new_mask is not None:\n        # Remove unnecessary values, is expected later anyway and enables\n        # downcasting\n        values = values[~new_mask]\n    elif (\n        dtype_backend is not lib.no_default\n        and new_mask is None\n        or isinstance(values_dtype, StringDtype)\n        and values_dtype.na_value is libmissing.NA\n    ):\n        new_mask = np.zeros(values.shape, dtype=np.bool_)\n\n    # attempt downcast only if the data has been successfully converted\n    # to a numerical dtype and if a downcast method has been specified\n    if downcast is not None and is_numeric_dtype(values.dtype):\n        typecodes: str | None = None\n\n        if downcast in (\"integer\", \"signed\"):\n            typecodes = np.typecodes[\"Integer\"]\n        elif downcast == \"unsigned\" and (not len(values) or np.min(values) >= 0):\n            typecodes = np.typecodes[\"UnsignedInteger\"]\n        elif downcast == \"float\":\n            typecodes = np.typecodes[\"Float\"]\n\n            # pandas support goes only to np.float32,\n            # as float dtypes smaller than that are\n            # extremely rare and not well supported\n            float_32_char = np.dtype(np.float32).char\n            float_32_ind = typecodes.index(float_32_char)\n            typecodes = typecodes[float_32_ind:]\n\n        if typecodes is not None:\n            # from smallest to largest\n            for typecode in typecodes:\n                dtype = np.dtype(typecode)\n                if dtype.itemsize <= values.dtype.itemsize:\n                    values = maybe_downcast_numeric(values, dtype)\n\n                    # successful conversion\n                    if values.dtype == dtype:\n                        break\n\n    # GH33013: for IntegerArray, BooleanArray & FloatingArray need to reconstruct\n    # masked array\n    if (mask is not None or new_mask is not None) and not is_string_dtype(values.dtype):\n        if mask is None or (new_mask is not None and new_mask.shape == mask.shape):\n            # GH 52588\n            mask = new_mask\n        else:\n            mask = mask.copy()\n        assert isinstance(mask, np.ndarray)\n        data = np.zeros(mask.shape, dtype=values.dtype)\n        data[~mask] = values\n\n        from pandas.core.arrays import (\n            ArrowExtensionArray,\n            BooleanArray,\n            FloatingArray,\n            IntegerArray,\n        )\n\n        klass: type[IntegerArray | BooleanArray | FloatingArray]\n        if is_integer_dtype(data.dtype):\n            klass = IntegerArray\n        elif is_bool_dtype(data.dtype):\n            klass = BooleanArray\n        else:\n            klass = FloatingArray\n        values = klass(data, mask)\n\n        if dtype_backend == \"pyarrow\" or isinstance(values_dtype, ArrowDtype):\n            values = ArrowExtensionArray(values.__arrow_array__())\n\n    if is_series:\n        return arg._constructor(values, index=arg.index, name=arg.name)\n    elif is_index:\n        # because we want to coerce to numeric if possible,\n        # do not use _shallow_copy\n        from pandas import Index\n\n        return Index(values, name=arg.name)\n    elif is_scalars:\n        return values[0]\n    else:\n        return values\n"
}