{
  "package": "pandas",
  "version": "2.3.3",
  "qualified_name": "pandas.core.tools.datetimes.to_datetime",
  "file": "/var/folders/8y/1_rm_t850ndf6rxl9ggy1qdh0000gn/T/spec_pandas_px6lnp0l/pandas-2.3.3/pandas/core/tools/datetimes.py",
  "signature": "(arg: DatetimeScalarOrArrayConvertible | DictConvertible, errors: DateTimeErrorChoices = 'raise', dayfirst: bool = False, yearfirst: bool = False, utc: bool = False, format: str | None = None, exact: bool | lib.NoDefault = lib.no_default, unit: str | None = None, infer_datetime_format: lib.NoDefault | bool = lib.no_default, origin: str = 'unix', cache: bool = True) -> DatetimeIndex | Series | DatetimeScalar | NaTType | None",
  "parameters": [
    {
      "name": "arg",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "DatetimeScalarOrArrayConvertible | DictConvertible",
      "default": null,
      "required": true,
      "nullable": false,
      "enum": null,
      "description": "The object to convert to a datetime. If a :class:`DataFrame` is provided, the method expects minimally the following columns: :const:`\"year\"`, :const:`\"month\"`, :const:`\"day\"`. The column \"year\" must be specified in 4-digit format."
    },
    {
      "name": "errors",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "DateTimeErrorChoices",
      "default": "'raise'",
      "required": false,
      "nullable": false,
      "enum": [
        "ignore",
        "raise",
        "coerce"
      ],
      "description": "- If :const:`'raise'`, then invalid parsing will raise an exception. - If :const:`'coerce'`, then invalid parsing will be set as :const:`NaT`. - If :const:`'ignore'`, then invalid parsing will return the input."
    },
    {
      "name": "dayfirst",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "bool",
      "default": "False",
      "required": false,
      "nullable": false,
      "enum": null,
      "description": "Specify a date parse order if `arg` is str or is list-like."
    },
    {
      "name": "yearfirst",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "bool",
      "default": "False",
      "required": false,
      "nullable": false,
      "enum": null,
      "description": "Specify a date parse order if `arg` is str or is list-like."
    },
    {
      "name": "utc",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "bool",
      "default": "False",
      "required": false,
      "nullable": false,
      "enum": null,
      "description": "Control timezone-related parsing, localization and conversion."
    },
    {
      "name": "format",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "str | None",
      "default": "None",
      "required": false,
      "nullable": false,
      "enum": null,
      "description": "The strftime to parse time, e.g. :const:`\"%d/%m/%Y\"`. See `strftime documentation <https://docs.python.org/3/library/datetime.html #strftime-and-strptime-behavior>`_ for more information on choices, though note that :const:`\"%f\"` will parse all the way up to nanoseconds. You can also pass:"
    },
    {
      "name": "exact",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "bool | lib.NoDefault",
      "default": "lib.no_default",
      "required": false,
      "nullable": false,
      "enum": null,
      "description": "Control how `format` is used:"
    },
    {
      "name": "unit",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "str | None",
      "default": "None",
      "required": false,
      "nullable": false,
      "enum": null,
      "description": "The unit of the arg (D,s,ms,us,ns) denote the unit, which is an integer or float number. This will be based off the origin. Example, with ``unit='ms'`` and ``origin='unix'``, this would calculate the number of milliseconds to the unix epoch start."
    },
    {
      "name": "infer_datetime_format",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "lib.NoDefault | bool",
      "default": "lib.no_default",
      "required": false,
      "nullable": false,
      "enum": null,
      "description": null
    },
    {
      "name": "origin",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "str",
      "default": "'unix'",
      "required": false,
      "nullable": false,
      "enum": null,
      "description": "Define the reference date. The numeric values would be parsed as number of units (defined by `unit`) since this reference date."
    },
    {
      "name": "cache",
      "kind": "POSITIONAL_OR_KEYWORD",
      "type": "bool",
      "default": "True",
      "required": false,
      "nullable": false,
      "enum": null,
      "description": null
    }
  ],
  "returns": {
    "type": "DatetimeIndex | Series | DatetimeScalar | NaTType | None",
    "description": "datetime\n    If parsing succeeded.\n    Return type depends on input (types in parenthesis correspond to\n    fallback in case of unsuccessful timezone or out-of-range timestamp\n    parsing):\n\n    - scalar: :class:`Timestamp` (or :class:`datetime.datetime`)\n    - array-like: :class:`DatetimeIndex` (or :class:`Series` with\n      :class:`object` dtype containing :class:`datetime.datetime`)\n    - Series: :class:`Series` of :class:`datetime64` dtype (or\n      :class:`Series` of :class:`object` dtype containing\n      :class:`datetime.datetime`)\n    - DataFrame: :class:`Series` of :class:`datetime64` dtype (or\n      :class:`Series` of :class:`object` dtype containing\n      :class:`datetime.datetime`)"
  },
  "raises": [
    "ParserError",
    "When parsing a date from string fails.",
    "ValueError",
    "When another datetime conversion error happens. For example when one",
    "of 'year', 'month', day' columns is missing in a :class:`DataFrame`, or",
    "when a Timezone-aware :class:`datetime.datetime` is found in an array-like",
    "of mixed time offsets, and ``utc=False``.",
    "See Also",
    "",
    "DataFrame.astype : Cast argument to a specified dtype.",
    "to_timedelta : Convert argument to timedelta.",
    "convert_dtypes : Convert dtypes."
  ],
  "notes": [
    "Many input types are supported, and lead to different output types:",
    "- **scalars** can be int, float, str, datetime object (from stdlib :mod:`datetime`",
    "module or :mod:`numpy`). They are converted to :class:`Timestamp` when",
    "possible, otherwise they are converted to :class:`datetime.datetime`.",
    "None/NaN/null scalars are converted to :const:`NaT`.",
    "- **array-like** can contain int, float, str, datetime objects. They are",
    "converted to :class:`DatetimeIndex` when possible, otherwise they are",
    "converted to :class:`Index` with :class:`object` dtype, containing",
    ":class:`datetime.datetime`. None/NaN/null entries are converted to",
    ":const:`NaT` in both cases.",
    "- **Series** are converted to :class:`Series` with :class:`datetime64`",
    "dtype when possible, otherwise they are converted to :class:`Series` with",
    ":class:`object` dtype, containing :class:`datetime.datetime`. None/NaN/null",
    "entries are converted to :const:`NaT` in both cases.",
    "- **DataFrame/dict-like** are converted to :class:`Series` with",
    ":class:`datetime64` dtype. For each row a datetime is created from assembling",
    "the various dataframe columns. Column keys can be common abbreviations",
    "like ['year', 'month', 'day', 'minute', 'second', 'ms', 'us', 'ns']) or",
    "plurals of the same.",
    "The following causes are responsible for :class:`datetime.datetime` objects",
    "being returned (possibly inside an :class:`Index` or a :class:`Series` with",
    ":class:`object` dtype) instead of a proper pandas designated type",
    "(:class:`Timestamp`, :class:`DatetimeIndex` or :class:`Series`",
    "with :class:`datetime64` dtype):",
    "- when any input element is before :const:`Timestamp.min` or after",
    ":const:`Timestamp.max`, see `timestamp limitations",
    "<https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html",
    "#timeseries-timestamp-limits>`_.",
    "- when ``utc=False`` (default) and the input is an array-like or",
    ":class:`Series` containing mixed naive/aware datetime, or aware with mixed",
    "time offsets. Note that this happens in the (quite frequent) situation when",
    "the timezone has a daylight savings policy. In that case you may wish to",
    "use ``utc=True``."
  ],
  "examples_code": [
    "df = pd.DataFrame({'year': [2015, 2016],\n                   'month': [2, 3],\n                   'day': [4, 5]})\npd.to_datetime(df)",
    "pd.to_datetime(1490195805, unit='s')",
    "pd.to_datetime(1490195805433502912, unit='ns')",
    "pd.to_datetime([1, 2, 3], unit='D',\n               origin=pd.Timestamp('1960-01-01'))",
    "pd.to_datetime('2018-10-26 12:00:00.0000000011',\n               format='%Y-%m-%d %H:%M:%S.%f')",
    "pd.to_datetime('13000101', format='%Y%m%d', errors='coerce')",
    "pd.to_datetime(['2018-10-26 12:00:00', '2018-10-26 13:00:15'])",
    "pd.to_datetime(['2018-10-26 12:00 -0500', '2018-10-26 13:00 -0500'])",
    "pd.to_datetime(['2020-10-25 02:00 +0200',\n                '2020-10-25 04:00 +0100'])  # doctest: +SKIP",
    "from datetime import datetime\npd.to_datetime([\"2020-01-01 01:00:00-01:00\",\n                datetime(2020, 1, 1, 3, 0)])  # doctest: +SKIP",
    "pd.to_datetime(['2018-10-26 12:00', '2018-10-26 13:00'], utc=True)",
    "pd.to_datetime(['2018-10-26 12:00 -0530', '2018-10-26 12:00 -0500'],\n               utc=True)",
    "pd.to_datetime(['2018-10-26 12:00', datetime(2020, 1, 1, 18)], utc=True)"
  ],
  "module_imports": [
    "from __future__ import annotations",
    "from collections import abc",
    "from datetime import date",
    "from functools import partial",
    "from itertools import islice",
    "from typing import (",
    "import warnings",
    "import numpy as np",
    "from pandas._config import using_string_dtype",
    "from pandas._libs import (",
    "from pandas._libs.tslibs import (",
    "from pandas._libs.tslibs.conversion import cast_from_unit_vectorized",
    "from pandas._libs.tslibs.parsing import (",
    "from pandas._libs.tslibs.strptime import array_strptime",
    "from pandas._typing import (",
    "from pandas.util._exceptions import find_stack_level",
    "from pandas.core.dtypes.common import (",
    "from pandas.core.dtypes.dtypes import (",
    "from pandas.core.dtypes.generic import (",
    "from pandas.arrays import (",
    "from pandas.core.algorithms import unique",
    "from pandas.core.arrays import ArrowExtensionArray",
    "from pandas.core.arrays.base import ExtensionArray",
    "from pandas.core.arrays.datetimes import (",
    "from pandas.core.construction import extract_array",
    "from pandas.core.indexes.base import Index",
    "from pandas.core.indexes.datetimes import DatetimeIndex",
    "    from collections.abc import Hashable",
    "    from pandas._libs.tslibs.nattype import NaTType",
    "    from pandas._libs.tslibs.timedeltas import UnitChoices",
    "    from pandas import (",
    "    from pandas import Series",
    "    from pandas import Series",
    "            from pandas import Series",
    "    from pandas import ("
  ],
  "body_stripped": "def to_datetime(\n    arg: DatetimeScalarOrArrayConvertible | DictConvertible,\n    errors: DateTimeErrorChoices = \"raise\",\n    dayfirst: bool = False,\n    yearfirst: bool = False,\n    utc: bool = False,\n    format: str | None = None,\n    exact: bool | lib.NoDefault = lib.no_default,\n    unit: str | None = None,\n    infer_datetime_format: lib.NoDefault | bool = lib.no_default,\n    origin: str = \"unix\",\n    cache: bool = True,\n) -> DatetimeIndex | Series | DatetimeScalar | NaTType | None:\n    \"\"\"\n    Convert argument to datetime.\n\n    This function converts a scalar, array-like, :class:`Series` or\n    :class:`DataFrame`/dict-like to a pandas datetime object.\n\n    Parameters\n    ----------\n    arg : int, float, str, datetime, list, tuple, 1-d array, Series, DataFrame/dict-like\n        The object to convert to a datetime. If a :class:`DataFrame` is provided, the\n        method expects minimally the following columns: :const:`\"year\"`,\n        :const:`\"month\"`, :const:`\"day\"`. The column \"year\"\n        must be specified in 4-digit format.\n    errors : {'ignore', 'raise', 'coerce'}, default 'raise'\n        - If :const:`'raise'`, then invalid parsing will raise an exception.\n        - If :const:`'coerce'`, then invalid parsing will be set as :const:`NaT`.\n        - If :const:`'ignore'`, then invalid parsing will return the input.\n    dayfirst : bool, default False\n        Specify a date parse order if `arg` is str or is list-like.\n        If :const:`True`, parses dates with the day first, e.g. :const:`\"10/11/12\"`\n        is parsed as :const:`2012-11-10`.\n\n        .. warning::\n\n            ``dayfirst=True`` is not strict, but will prefer to parse\n            with day first.\n\n    yearfirst : bool, default False\n        Specify a date parse order if `arg` is str or is list-like.\n\n        - If :const:`True` parses dates with the year first, e.g.\n          :const:`\"10/11/12\"` is parsed as :const:`2010-11-12`.\n        - If both `dayfirst` and `yearfirst` are :const:`True`, `yearfirst` is\n          preceded (same as :mod:`dateutil`).\n\n        .. warning::\n\n            ``yearfirst=True`` is not strict, but will prefer to parse\n            with year first.\n\n    utc : bool, default False\n        Control timezone-related parsing, localization and conversion.\n\n        - If :const:`True`, the function *always* returns a timezone-aware\n          UTC-localized :class:`Timestamp`, :class:`Series` or\n          :class:`DatetimeIndex`. To do this, timezone-naive inputs are\n          *localized* as UTC, while timezone-aware inputs are *converted* to UTC.\n\n        - If :const:`False` (default), inputs will not be coerced to UTC.\n          Timezone-naive inputs will remain naive, while timezone-aware ones\n          will keep their time offsets. Limitations exist for mixed\n          offsets (typically, daylight savings), see :ref:`Examples\n          <to_datetime_tz_examples>` section for details.\n\n        .. warning::\n\n            In a future version of pandas, parsing datetimes with mixed time\n            zones will raise an error unless `utc=True`.\n            Please specify `utc=True` to opt in to the new behaviour\n            and silence this warning. To create a `Series` with mixed offsets and\n            `object` dtype, please use `apply` and `datetime.datetime.strptime`.\n\n        See also: pandas general documentation about `timezone conversion and\n        localization\n        <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html\n        #time-zone-handling>`_.\n\n    format : str, default None\n        The strftime to parse time, e.g. :const:`\"%d/%m/%Y\"`. See\n        `strftime documentation\n        <https://docs.python.org/3/library/datetime.html\n        #strftime-and-strptime-behavior>`_ for more information on choices, though\n        note that :const:`\"%f\"` will parse all the way up to nanoseconds.\n        You can also pass:\n\n        - \"ISO8601\", to parse any `ISO8601 <https://en.wikipedia.org/wiki/ISO_8601>`_\n          time string (not necessarily in exactly the same format);\n        - \"mixed\", to infer the format for each element individually. This is risky,\n          and you should probably use it along with `dayfirst`.\n\n        .. note::\n\n            If a :class:`DataFrame` is passed, then `format` has no effect.\n\n    exact : bool, default True\n        Control how `format` is used:\n\n        - If :const:`True`, require an exact `format` match.\n        - If :const:`False`, allow the `format` to match anywhere in the target\n          string.\n\n        Cannot be used alongside ``format='ISO8601'`` or ``format='mixed'``.\n    unit : str, default 'ns'\n        The unit of the arg (D,s,ms,us,ns) denote the unit, which is an\n        integer or float number. This will be based off the origin.\n        Example, with ``unit='ms'`` and ``origin='unix'``, this would calculate\n        the number of milliseconds to the unix epoch start.\n    infer_datetime_format : bool, default False\n        If :const:`True` and no `format` is given, attempt to infer the format\n        of the datetime strings based on the first non-NaN element,\n        and if it can be inferred, switch to a faster method of parsing them.\n        In some cases this can increase the parsing speed by ~5-10x.\n\n        .. deprecated:: 2.0.0\n            A strict version of this argument is now the default, passing it has\n            no effect.\n\n    origin : scalar, default 'unix'\n        Define the reference date. The numeric values would be parsed as number\n        of units (defined by `unit`) since this reference date.\n\n        - If :const:`'unix'` (or POSIX) time; origin is set to 1970-01-01.\n        - If :const:`'julian'`, unit must be :const:`'D'`, and origin is set to\n          beginning of Julian Calendar. Julian day number :const:`0` is assigned\n          to the day starting at noon on January 1, 4713 BC.\n        - If Timestamp convertible (Timestamp, dt.datetime, np.datetimt64 or date\n          string), origin is set to Timestamp identified by origin.\n        - If a float or integer, origin is the difference\n          (in units determined by the ``unit`` argument) relative to 1970-01-01.\n    cache : bool, default True\n        If :const:`True`, use a cache of unique, converted dates to apply the\n        datetime conversion. May produce significant speed-up when parsing\n        duplicate date strings, especially ones with timezone offsets. The cache\n        is only used when there are at least 50 values. The presence of\n        out-of-bounds values will render the cache unusable and may slow down\n        parsing.\n\n    Returns\n    -------\n    datetime\n        If parsing succeeded.\n        Return type depends on input (types in parenthesis correspond to\n        fallback in case of unsuccessful timezone or out-of-range timestamp\n        parsing):\n\n        - scalar: :class:`Timestamp` (or :class:`datetime.datetime`)\n        - array-like: :class:`DatetimeIndex` (or :class:`Series` with\n          :class:`object` dtype containing :class:`datetime.datetime`)\n        - Series: :class:`Series` of :class:`datetime64` dtype (or\n          :class:`Series` of :class:`object` dtype containing\n          :class:`datetime.datetime`)\n        - DataFrame: :class:`Series` of :class:`datetime64` dtype (or\n          :class:`Series` of :class:`object` dtype containing\n          :class:`datetime.datetime`)\n\n    Raises\n    ------\n    ParserError\n        When parsing a date from string fails.\n    ValueError\n        When another datetime conversion error happens. For example when one\n        of 'year', 'month', day' columns is missing in a :class:`DataFrame`, or\n        when a Timezone-aware :class:`datetime.datetime` is found in an array-like\n        of mixed time offsets, and ``utc=False``.\n\n    See Also\n    --------\n    DataFrame.astype : Cast argument to a specified dtype.\n    to_timedelta : Convert argument to timedelta.\n    convert_dtypes : Convert dtypes.\n\n    Notes\n    -----\n\n    Many input types are supported, and lead to different output types:\n\n    - **scalars** can be int, float, str, datetime object (from stdlib :mod:`datetime`\n      module or :mod:`numpy`). They are converted to :class:`Timestamp` when\n      possible, otherwise they are converted to :class:`datetime.datetime`.\n      None/NaN/null scalars are converted to :const:`NaT`.\n\n    - **array-like** can contain int, float, str, datetime objects. They are\n      converted to :class:`DatetimeIndex` when possible, otherwise they are\n      converted to :class:`Index` with :class:`object` dtype, containing\n      :class:`datetime.datetime`. None/NaN/null entries are converted to\n      :const:`NaT` in both cases.\n\n    - **Series** are converted to :class:`Series` with :class:`datetime64`\n      dtype when possible, otherwise they are converted to :class:`Series` with\n      :class:`object` dtype, containing :class:`datetime.datetime`. None/NaN/null\n      entries are converted to :const:`NaT` in both cases.\n\n    - **DataFrame/dict-like** are converted to :class:`Series` with\n      :class:`datetime64` dtype. For each row a datetime is created from assembling\n      the various dataframe columns. Column keys can be common abbreviations\n      like ['year', 'month', 'day', 'minute', 'second', 'ms', 'us', 'ns']) or\n      plurals of the same.\n\n    The following causes are responsible for :class:`datetime.datetime` objects\n    being returned (possibly inside an :class:`Index` or a :class:`Series` with\n    :class:`object` dtype) instead of a proper pandas designated type\n    (:class:`Timestamp`, :class:`DatetimeIndex` or :class:`Series`\n    with :class:`datetime64` dtype):\n\n    - when any input element is before :const:`Timestamp.min` or after\n      :const:`Timestamp.max`, see `timestamp limitations\n      <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html\n      #timeseries-timestamp-limits>`_.\n\n    - when ``utc=False`` (default) and the input is an array-like or\n      :class:`Series` containing mixed naive/aware datetime, or aware with mixed\n      time offsets. Note that this happens in the (quite frequent) situation when\n      the timezone has a daylight savings policy. In that case you may wish to\n      use ``utc=True``.\n\n    Examples\n    --------\n\n    **Handling various input formats**\n\n    Assembling a datetime from multiple columns of a :class:`DataFrame`. The keys\n    can be common abbreviations like ['year', 'month', 'day', 'minute', 'second',\n    'ms', 'us', 'ns']) or plurals of the same\n\n    >>> df = pd.DataFrame({'year': [2015, 2016],\n    ...                    'month': [2, 3],\n    ...                    'day': [4, 5]})\n    >>> pd.to_datetime(df)\n    0   2015-02-04\n    1   2016-03-05\n    dtype: datetime64[ns]\n\n    Using a unix epoch time\n\n    >>> pd.to_datetime(1490195805, unit='s')\n    Timestamp('2017-03-22 15:16:45')\n    >>> pd.to_datetime(1490195805433502912, unit='ns')\n    Timestamp('2017-03-22 15:16:45.433502912')\n\n    .. warning:: For float arg, precision rounding might happen. To prevent\n        unexpected behavior use a fixed-width exact type.\n\n    Using a non-unix epoch origin\n\n    >>> pd.to_datetime([1, 2, 3], unit='D',\n    ...                origin=pd.Timestamp('1960-01-01'))\n    DatetimeIndex(['1960-01-02', '1960-01-03', '1960-01-04'],\n                  dtype='datetime64[ns]', freq=None)\n\n    **Differences with strptime behavior**\n\n    :const:`\"%f\"` will parse all the way up to nanoseconds.\n\n    >>> pd.to_datetime('2018-10-26 12:00:00.0000000011',\n    ...                format='%Y-%m-%d %H:%M:%S.%f')\n    Timestamp('2018-10-26 12:00:00.000000001')\n\n    **Non-convertible date/times**\n\n    Passing ``errors='coerce'`` will force an out-of-bounds date to :const:`NaT`,\n    in addition to forcing non-dates (or non-parseable dates) to :const:`NaT`.\n\n    >>> pd.to_datetime('13000101', format='%Y%m%d', errors='coerce')\n    NaT\n\n    .. _to_datetime_tz_examples:\n\n    **Timezones and time offsets**\n\n    The default behaviour (``utc=False``) is as follows:\n\n    - Timezone-naive inputs are converted to timezone-naive :class:`DatetimeIndex`:\n\n    >>> pd.to_datetime(['2018-10-26 12:00:00', '2018-10-26 13:00:15'])\n    DatetimeIndex(['2018-10-26 12:00:00', '2018-10-26 13:00:15'],\n                  dtype='datetime64[ns]', freq=None)\n\n    - Timezone-aware inputs *with constant time offset* are converted to\n      timezone-aware :class:`DatetimeIndex`:\n\n    >>> pd.to_datetime(['2018-10-26 12:00 -0500', '2018-10-26 13:00 -0500'])\n    DatetimeIndex(['2018-10-26 12:00:00-05:00', '2018-10-26 13:00:00-05:00'],\n                  dtype='datetime64[ns, UTC-05:00]', freq=None)\n\n    - However, timezone-aware inputs *with mixed time offsets* (for example\n      issued from a timezone with daylight savings, such as Europe/Paris)\n      are **not successfully converted** to a :class:`DatetimeIndex`.\n      Parsing datetimes with mixed time zones will show a warning unless\n      `utc=True`. If you specify `utc=False` the warning below will be shown\n      and a simple :class:`Index` containing :class:`datetime.datetime`\n      objects will be returned:\n\n    >>> pd.to_datetime(['2020-10-25 02:00 +0200',\n    ...                 '2020-10-25 04:00 +0100'])  # doctest: +SKIP\n    FutureWarning: In a future version of pandas, parsing datetimes with mixed\n    time zones will raise an error unless `utc=True`. Please specify `utc=True`\n    to opt in to the new behaviour and silence this warning. To create a `Series`\n    with mixed offsets and `object` dtype, please use `apply` and\n    `datetime.datetime.strptime`.\n    Index([2020-10-25 02:00:00+02:00, 2020-10-25 04:00:00+01:00],\n          dtype='object')\n\n    - A mix of timezone-aware and timezone-naive inputs is also converted to\n      a simple :class:`Index` containing :class:`datetime.datetime` objects:\n\n    >>> from datetime import datetime\n    >>> pd.to_datetime([\"2020-01-01 01:00:00-01:00\",\n    ...                 datetime(2020, 1, 1, 3, 0)])  # doctest: +SKIP\n    FutureWarning: In a future version of pandas, parsing datetimes with mixed\n    time zones will raise an error unless `utc=True`. Please specify `utc=True`\n    to opt in to the new behaviour and silence this warning. To create a `Series`\n    with mixed offsets and `object` dtype, please use `apply` and\n    `datetime.datetime.strptime`.\n    Index([2020-01-01 01:00:00-01:00, 2020-01-01 03:00:00], dtype='object')\n\n    |\n\n    Setting ``utc=True`` solves most of the above issues:\n\n    - Timezone-naive inputs are *localized* as UTC\n\n    >>> pd.to_datetime(['2018-10-26 12:00', '2018-10-26 13:00'], utc=True)\n    DatetimeIndex(['2018-10-26 12:00:00+00:00', '2018-10-26 13:00:00+00:00'],\n                  dtype='datetime64[ns, UTC]', freq=None)\n\n    - Timezone-aware inputs are *converted* to UTC (the output represents the\n      exact same datetime, but viewed from the UTC time offset `+00:00`).\n\n    >>> pd.to_datetime(['2018-10-26 12:00 -0530', '2018-10-26 12:00 -0500'],\n    ...                utc=True)\n    DatetimeIndex(['2018-10-26 17:30:00+00:00', '2018-10-26 17:00:00+00:00'],\n                  dtype='datetime64[ns, UTC]', freq=None)\n\n    - Inputs can contain both string or datetime, the above\n      rules still apply\n\n    >>> pd.to_datetime(['2018-10-26 12:00', datetime(2020, 1, 1, 18)], utc=True)\n    DatetimeIndex(['2018-10-26 12:00:00+00:00', '2020-01-01 18:00:00+00:00'],\n                  dtype='datetime64[ns, UTC]', freq=None)\n    \"\"\"\n    if exact is not lib.no_default and format in {\"mixed\", \"ISO8601\"}:\n        raise ValueError(\"Cannot use 'exact' when 'format' is 'mixed' or 'ISO8601'\")\n    if infer_datetime_format is not lib.no_default:\n        warnings.warn(\n            \"The argument 'infer_datetime_format' is deprecated and will \"\n            \"be removed in a future version. \"\n            \"A strict version of it is now the default, see \"\n            \"https://pandas.pydata.org/pdeps/0004-consistent-to-datetime-parsing.html. \"\n            \"You can safely remove this argument.\",\n            stacklevel=find_stack_level(),\n        )\n    if errors == \"ignore\":\n        # GH#54467\n        warnings.warn(\n            \"errors='ignore' is deprecated and will raise in a future version. \"\n            \"Use to_datetime without passing `errors` and catch exceptions \"\n            \"explicitly instead\",\n            FutureWarning,\n            stacklevel=find_stack_level(),\n        )\n\n    if arg is None:\n        return None\n\n    if origin != \"unix\":\n        arg = _adjust_to_origin(arg, origin, unit)\n\n    convert_listlike = partial(\n        _convert_listlike_datetimes,\n        utc=utc,\n        unit=unit,\n        dayfirst=dayfirst,\n        yearfirst=yearfirst,\n        errors=errors,\n        exact=exact,\n    )\n    # pylint: disable-next=used-before-assignment\n    result: Timestamp | NaTType | Series | Index\n\n    if isinstance(arg, Timestamp):\n        result = arg\n        if utc:\n            if arg.tz is not None:\n                result = arg.tz_convert(\"utc\")\n            else:\n                result = arg.tz_localize(\"utc\")\n    elif isinstance(arg, ABCSeries):\n        cache_array = _maybe_cache(arg, format, cache, convert_listlike)\n        if not cache_array.empty:\n            result = arg.map(cache_array)\n        else:\n            values = convert_listlike(arg._values, format)\n            result = arg._constructor(values, index=arg.index, name=arg.name)\n    elif isinstance(arg, (ABCDataFrame, abc.MutableMapping)):\n        result = _assemble_from_unit_mappings(arg, errors, utc)\n    elif isinstance(arg, Index):\n        cache_array = _maybe_cache(arg, format, cache, convert_listlike)\n        if not cache_array.empty:\n            result = _convert_and_box_cache(arg, cache_array, name=arg.name)\n        else:\n            result = convert_listlike(arg, format, name=arg.name)\n    elif is_list_like(arg):\n        try:\n            # error: Argument 1 to \"_maybe_cache\" has incompatible type\n            # \"Union[float, str, datetime, List[Any], Tuple[Any, ...], ExtensionArray,\n            # ndarray[Any, Any], Series]\"; expected \"Union[List[Any], Tuple[Any, ...],\n            # Union[Union[ExtensionArray, ndarray[Any, Any]], Index, Series], Series]\"\n            argc = cast(\n                Union[list, tuple, ExtensionArray, np.ndarray, \"Series\", Index], arg\n            )\n            cache_array = _maybe_cache(argc, format, cache, convert_listlike)\n        except OutOfBoundsDatetime:\n            # caching attempts to create a DatetimeIndex, which may raise\n            # an OOB. If that's the desired behavior, then just reraise...\n            if errors == \"raise\":\n                raise\n            # ... otherwise, continue without the cache.\n            from pandas import Series\n\n            cache_array = Series([], dtype=object)  # just an empty array\n        if not cache_array.empty:\n            result = _convert_and_box_cache(argc, cache_array)\n        else:\n            result = convert_listlike(argc, format)\n    else:\n        result = convert_listlike(np.array([arg]), format)[0]\n        if isinstance(arg, bool) and isinstance(result, np.bool_):\n            result = bool(result)  # TODO: avoid this kludge.\n\n    #  error: Incompatible return value type (got \"Union[Timestamp, NaTType,\n    # Series, Index]\", expected \"Union[DatetimeIndex, Series, float, str,\n    # NaTType, None]\")\n    return result  # type: ignore[return-value]\n"
}